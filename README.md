# Data Structures And Algorithms
#### 数据结构与算法的知识点demo，剑指offer题库刷题，以及leetcode的刷题记录
## 剑指offer
### 36. 两个链表的第一个公共节点
问题描述  
输入两个链表，找出它们的第一个公共结点。  
解题思路  
如果两个链表有公共节点，那么最后一个节点必然是公共节点，因此可以从最后一个公共节点向前找：先将俩链表压入栈，然后同时出栈，直到找到第一个公共节点结束。

## 力扣（Leetcode）
### 1. 两数之和
    给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
    
    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。
    
     
    
    示例:
    
    给定 nums = [2, 7, 11, 15], target = 9
    
    因为 nums[0] + nums[1] = 2 + 7 = 9
    所以返回 [0, 1]
* [q1_两数之和](/src/main/java/leetcode/algorithms/Q1.java)
### 2. 两数相加
    给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。
    
    如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。
    
    您可以假设除了数字 0 之外，这两个数都不会以 0 开头。
    
    示例：
    
    输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
    输出：7 -> 0 -> 8
    原因：342 + 465 = 807
### 3. 无重复字符的最长子串
    给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。
    
    示例 1:
    
    输入: "abcabcbb"
    输出: 3 
    解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
    示例 2:
    
    输入: "bbbbb"
    输出: 1
    解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
    示例 3:
    
    输入: "pwwkew"
    输出: 3
    解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
         请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
### 7. 整数反转
    给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。
    
    示例 1:
    
    输入: 123
    输出: 321
     示例 2:
    
    输入: -123
    输出: -321
    示例 3:
    
    输入: 120
    输出: 21
### 110. 正则表达式匹配
     给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。
     
     '.' 匹配任意单个字符
     '*' 匹配零个或多个前面的那一个元素
     所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。
     
     说明:
     
     s 可能为空，且只包含从 a-z 的小写字母。
     p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。
     示例 1:
     
     输入:
     s = "aa"
     p = "a"
     输出: false
     解释: "a" 无法匹配 "aa" 整个字符串。
     示例 2:
     
     输入:
     s = "aa"
     p = "a*"
     输出: true
     解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。
     示例 3:
     
     输入:
     s = "ab"
     p = ".*"
     输出: true
     解释: ".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。
     示例 4:
     
     输入:
     s = "aab"
     p = "c*a*b"
     输出: true
     解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。
     示例 5:
     
     输入:
     s = "mississippi"
     p = "mis*is*p*."
     输出: false

### 19. 删除链表的倒数第N个节点
    给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。
    
    示例：
    
    给定一个链表: 1->2->3->4->5, 和 n = 2.
    
    当删除了倒数第二个节点后，链表变为 1->2->3->5.
    说明：
    
    给定的 n 保证是有效的。
    
    进阶：
    
    你能尝试使用一趟扫描实现吗？
### 21. 合并两个有序链表
    将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 
    
    示例：
    
    输入：1->2->4, 1->3->4
    输出：1->1->2->3->4->4
### 23. 合并K个排序链表
    合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。
    
    示例:
    
    输入:
    [
      1->4->5,
      1->3->4,
      2->6
    ]
    输出: 1->1->2->3->4->4->5->6
### 61. 旋转链表
    给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。
    
    示例 1:
    
    输入: 1->2->3->4->5->NULL, k = 2
    输出: 4->5->1->2->3->NULL
    解释:
    向右旋转 1 步: 5->1->2->3->4->NULL
    向右旋转 2 步: 4->5->1->2->3->NULL
    示例 2:
    
    输入: 0->1->2->NULL, k = 4
    输出: 2->0->1->NULL
    解释:
    向右旋转 1 步: 2->0->1->NULL
    向右旋转 2 步: 1->2->0->NULL
    向右旋转 3 步: 0->1->2->NULL
    向右旋转 4 步: 2->0->1->NULL
### 94. 二叉树的中序遍历
    给定一个二叉树，返回它的中序 遍历。
    
    示例:
    
    输入: [1,null,2,3]
       1
        \
         2
        /
       3
    
    输出: [1,3,2]
    进阶: 递归算法很简单，你可以通过迭代算法完成吗？
### 102. 二叉树的层序遍历
    给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。
    
     
    
    示例：
    二叉树：[3,9,20,null,null,15,7],
    
        3
       / \
      9  20
        /  \
       15   7
    返回其层次遍历结果：
    
    [
      [3],
      [9,20],
      [15,7]
    ]
### 107. 二叉树的层次遍历 II
    给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）
    
    例如：
    给定二叉树 [3,9,20,null,null,15,7],
    
        3
       / \
      9  20
        /  \
       15   7
    返回其自底向上的层次遍历为：
    
    [
      [15,7],
      [9,20],
      [3]
    ]
### 110. 平衡二叉树
    给定一个二叉树，判断它是否是高度平衡的二叉树。
    
    本题中，一棵高度平衡二叉树定义为：
    
    一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。
    
    示例 1:
    
    给定二叉树 [3,9,20,null,null,15,7]
    
        3
       / \
      9  20
        /  \
       15   7
    返回 true 。
    
    示例 2:
    
    给定二叉树 [1,2,2,3,3,null,null,4,4]
    
           1
          / \
         2   2
        / \
       3   3
      / \
     4   4
    返回 false 。
### 138. 复制带随机指针的链表
    给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。
    
    要求返回这个链表的 深拷贝。 
    
    我们用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：
    
    val：一个表示 Node.val 的整数。
    random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。
     
    
    示例 1：
    
    
    
    输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
    输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
    示例 2：
    
    
    
    输入：head = [[1,1],[2,1]]
    输出：[[1,1],[2,1]]
    示例 3：
    
    
    
    输入：head = [[3,null],[3,0],[3,null]]
    输出：[[3,null],[3,0],[3,null]]
    示例 4：
    
    输入：head = []
    输出：[]
    解释：给定的链表为空（空指针），因此返回 null。
     
    
    提示：
    
    -10000 <= Node.val <= 10000
    Node.random 为空（null）或指向链表中的节点。
    节点数目不超过 1000 。
### 141. 环形链表
    给定一个链表，判断链表中是否有环。
    
    为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。
    
     
    
    示例 1：
    
    输入：head = [3,2,0,-4], pos = 1
    输出：true
    解释：链表中有一个环，其尾部连接到第二个节点。
    
    
    示例 2：
    
    输入：head = [1,2], pos = 0
    输出：true
    解释：链表中有一个环，其尾部连接到第一个节点。
    
    
    示例 3：
    
    输入：head = [1], pos = -1
    输出：false
    解释：链表中没有环。
    
    
     
    
    进阶：
    
    你能用 O(1)（即，常量）内存解决此问题吗？
### 144. 二叉树的前序遍历
    给定一个二叉树，返回它的 前序 遍历。
    
     示例:
    
    输入: [1,null,2,3]  
       1
        \
         2
        /
       3 
    
    输出: [1,2,3]
    进阶: 递归算法很简单，你可以通过迭代算法完成吗？
### 145. 二叉树的后序遍历
    给定一个二叉树，返回它的 后序 遍历。
    
    示例:
    
    输入: [1,null,2,3]  
       1
        \
         2
        /
       3 
    
    输出: [3,2,1]
### 206. 反转链表
    反转一个单链表。
    
    示例:
    
    输入: 1->2->3->4->5->NULL
    输出: 5->4->3->2->1->NULL
    进阶:
    你可以迭代或递归地反转链表。你能否用两种方法解决这道题？

### 98. 验证二叉搜索树
    给定一个二叉树，判断其是否是一个有效的二叉搜索树。
    
    假设一个二叉搜索树具有如下特征：
    
    节点的左子树只包含小于当前节点的数。
    节点的右子树只包含大于当前节点的数。
    所有左子树和右子树自身必须也是二叉搜索树。
    示例 1:
    
    输入:
        2
       / \
      1   3
    输出: true
    示例 2:
    
    输入:
        5
       / \
      1   4
         / \
        3   6
    输出: false
    解释: 输入为: [5,1,4,null,null,3,6]。
         根节点的值为 5 ，但是其右子节点值为 4 。